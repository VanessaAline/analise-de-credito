# -*- coding: utf-8 -*-
"""BomCliente_Projeto.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w-sI2KmoAsaunkreRTmXIPPx6ED4ITOA

# Importando Bibliotecas
"""

#Libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt;
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV

from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.neural_network import MLPClassifier

from sklearn import metrics

import warnings
warnings.filterwarnings("ignore")

#Carregando os dados
dados = pd.read_csv('Analise_de_credito.csv', sep=';')

dados.head()

"""# Conhecendo os dados"""

#(Linhas, Colunas)
dados.shape

#Nome das Colunas
dados.columns

dados['class'].unique()

dados['checking_status'].unique()

sns.countplot(x='checking_status', data=dados)
plt.show()

dados['credit_history'].unique()

sns.countplot(x='credit_history', data=dados)
plt.show()

sns.countplot(x='class', data=dados)
plt.show()

#Verificando se existe dados NULL no dataset
dados.isnull().sum()

dados.info()

"""# Tratando os dados"""

#Excluindo coluna desnecessária - ID
del dados['ID']

#Transformando as Colunas 'class' em Numérico
Classe = pd.get_dummies(dados['class'], drop_first=True)
#Classe

#Renomeando tudo que for igual á '<0' para Negativo
dados['checking_status'][dados['checking_status'] =='<0'] = 'Negativo'

#dados['checking_status'][dados['checking_status'] == 'Negativo']

dados['checking_status'][dados['checking_status'] !='Negativo'] = 'Positivo'

#dados['checking_status'][dados['checking_status'] == 'Positivo']

sns.countplot(x='checking_status', data=dados)
plt.show()

#Transformando a Coluna 'checking_status' em Numérico
Checking_S = pd.get_dummies(dados['checking_status'], drop_first=True)
#Checking_S

sns.countplot(x='credit_history', data=dados)
plt.show()

dados['credit_history'].unique()

#Transformando a Coluna 'credit_history'
dados['credit_history'][dados['credit_history'] =='existing paid'] = 'Existente Pago'
dados['credit_history'][dados['credit_history'] =='no credits/all paid'] = 'Sem crédito'
dados['credit_history'][dados['credit_history'] =='all paid'] = 'Em dias'
dados['credit_history'][dados['credit_history'] =='delayed previously'] = 'Em Atraso'
dados['credit_history'][dados['credit_history'] =='critical/other existing credit'] = 'Critico'

sns.countplot(x='credit_history', data=dados)
plt.show()

#Transformando a Coluna 'credit_history' em Numérico
Credit_H = pd.get_dummies(dados['credit_history'], drop_first=True)
Credit_H

#Deletando colunas inicias
dados.drop(['class','checking_status','credit_history'], axis=1,inplace=True)

#Concatenando com as colunas trasformadas
dados = pd.concat([dados,Classe,Checking_S,Credit_H],axis=1)

dados.head()

#Renomeando dataset
dados.columns = ['Duração', 'Qtd_de_Crédito', 'Parcelamento', 'Cliente_desde', 'Idade', 'Linha_Crédito_existente', 'Dependentes', 'Status_cliente', 'Saldo','Em Atraso','Em dias','Existente Pago','Sem crédito']

dados.head()

dados.info()

y = dados['Status_cliente']

del dados['Status_cliente']

X = dados

#Separando dados de treino e teste
X_train, X_test, y_train, y_test =  train_test_split(X,y,test_size = 0.25, random_state= 0)

"""# Preparação Para o GridSearch

# GridSearch Árvore
"""

decision_tree = DecisionTreeClassifier()

profundidade = [10, 15, 20, 50, 100]
criterio = ['gini', 'entropy']

melhor_entropy = 0
melhor_modelo = None


for p in profundidade:
  for c in criterio:

          cart = DecisionTreeClassifier (criterion= c, max_depth=p)
          cart.fit(X_train, y_train)
          prev_train = cart.predict(X_train)
          melhor_train = metrics.accuracy_score(y_train, prev_train)
          
          if melhor_train > melhor_entropy:
            melhor_entropy = melhor_train
            melhor_modelo = cart
            print("Melhor Modelo:", melhor_modelo)

melhor_cart = melhor_modelo

"""# GridSearch KNN"""

k = [1, 3, 5, 7, 9] #Usando valores impares para caso de empate
distancia = ['euclidean', 'manhattan']
peso = ['uniform','distance']

melhor_vizinho = 0
melhor_modelo = None

for k in k:
  for d in distancia:
    for p in peso:

          knn = KNeighborsClassifier (n_neighbors=k, metric=d, weights=p)
          knn.fit(X_train, y_train)
          prev_train = knn.predict(X_train)
          melhor_train = metrics.accuracy_score(y_train, prev_train)
          
          if melhor_train > melhor_vizinho:
            melhor_vizinho = melhor_train
            melhor_modelo = knn
            print("Melhor Modelo:", melhor_modelo)

melhor_vizinho = melhor_modelo

"""# GridSearch MLP"""

neuronios = [1, 10, 15, 20, 50, 100]
funcAtivacao = ['identity', 'logistic', 'tanh', 'relu']
algoTreinamento = ['sgd', 'adam']
taxaDeAprendizado = [0.001, 0.0001]

melhor_acuracy = 0
melhor_modelo = None
num_exe = 5


for n in neuronios:
  for f in funcAtivacao:
    for a in algoTreinamento:
      for tx in taxaDeAprendizado:

        for i in range(0, num_exe):


          mlp = MLPClassifier (hidden_layer_sizes=n,  activation=f, solver=a, learning_rate_init=tx )
          mlp.fit(X_train, y_train)
          prev_train = mlp.predict(X_train)
          melhor_train = metrics.accuracy_score(y_train, prev_train)
          
          if melhor_train > melhor_acuracy:
            melhor_acuracy = melhor_train
            melhor_modelo = mlp
            print("Melhor Modelo:", melhor_modelo)

melhor_mlp = melhor_modelo

"""# Modelagem

# Árvore de Decisão
"""

predict_train_cart = melhor_cart.predict(X_train)

"""# KNN"""

y_pred = melhor_vizinho.predict(X_train)

"""# MLP"""

predict_train_mlp = melhor_mlp.predict(X_train)

"""# Resultado Treinamento"""

acc_cart = metrics.accuracy_score(y_train, predict_train_cart)
acc_knn = metrics.accuracy_score(y_train, y_pred)
acc_mlp = metrics.accuracy_score(y_train, predict_train_mlp)
print("ACC da MLP em Treinamento", acc_mlp * 100)
print("ACC do KNN em Treinamento", acc_knn * 100)
print("ACC da Árvore em Treinamento", acc_cart * 100)

"""# Resultado Teste"""

cart_pred_test = cart.predict(X_test)
knn_pred_test = knn.predict(X_test)
mlp_pred_test = mlp.predict(X_test)

acc_cart = metrics.accuracy_score(y_test, cart_pred_test)
acc_knn = metrics.accuracy_score(y_test, knn_pred_test)
acc_mlp = metrics.accuracy_score(y_test, mlp_pred_test)

print("ACC da Arvore em Teste %.2f" %(acc_cart * 100))
print("ACC do KNN em Teste %.2f" %(acc_knn * 100))
print("ACC da MLP em Teste %.2f" %(acc_mlp * 100))

plt.bar(['Árvore', 'KNN', 'MLP'],[acc_cart*100, acc_knn*100, acc_mlp*100], color=['r', 'g', 'b'])